{"ast":null,"code":"import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeWaveShaperNode = nativeContext.createWaveShaper();\n    /*\n     * Bug #119: Safari does not correctly map the values.\n     * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n     * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n     * isn't necessary anymore since v14.0.2 of Safari.\n     */\n    if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext' && nativeContext.createGain().gain.automationRate === undefined) {\n      return createNativeWaveShaperNodeFaker(nativeContext, options);\n    }\n    assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n    const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n    // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n    if (curve !== null && curve.length < 2) {\n      throw createInvalidStateError();\n    }\n    // Only values of type Float32Array can be assigned to the curve property.\n    assignNativeAudioNodeOption(nativeWaveShaperNode, {\n      curve\n    }, 'curve');\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    overwriteAccessors(nativeWaveShaperNode, 'curve', get => () => get.call(nativeWaveShaperNode), set => value => {\n      set.call(nativeWaveShaperNode, value);\n      if (isConnected) {\n        if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n        } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n          disconnectNativeAudioBufferSourceNode();\n          disconnectNativeAudioBufferSourceNode = null;\n        }\n      }\n      return value;\n    });\n    const whenConnected = () => {\n      isConnected = true;\n      if (isDCCurve(nativeWaveShaperNode.curve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n      }\n    };\n    const whenDisconnected = () => {\n      isConnected = false;\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n    return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"names":["assignNativeAudioNodeOption","assignNativeAudioNodeOptions","createNativeWaveShaperNodeFactory","createConnectedNativeAudioBufferSourceNode","createInvalidStateError","createNativeWaveShaperNodeFaker","isDCCurve","monitorConnections","nativeAudioContextConstructor","overwriteAccessors","nativeContext","options","nativeWaveShaperNode","createWaveShaper","name","createGain","gain","automationRate","undefined","curve","Float32Array","length","disconnectNativeAudioBufferSourceNode","isConnected","get","call","set","value","whenConnected","whenDisconnected"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js"],"sourcesContent":["import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', (get) => () => get.call(nativeWaveShaperNode), (set) => (value) => {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n                if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                    disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n                }\n                else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                    disconnectNativeAudioBufferSourceNode();\n                    disconnectNativeAudioBufferSourceNode = null;\n                }\n            }\n            return value;\n        });\n        const whenConnected = () => {\n            isConnected = true;\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-factory.js.map"],"mappings":"AAAA,SAASA,2BAA2B,QAAQ,4CAA4C;AACxF,SAASC,4BAA4B,QAAQ,6CAA6C;AAC1F,OAAO,MAAMC,iCAAiC,GAAGA,CAACC,0CAA0C,EAAEC,uBAAuB,EAAEC,+BAA+B,EAAEC,SAAS,EAAEC,kBAAkB,EAAEC,6BAA6B,EAAEC,kBAAkB,KAAK;EACzO,OAAO,CAACC,aAAa,EAAEC,OAAO,KAAK;IAC/B,MAAMC,oBAAoB,GAAGF,aAAa,CAACG,gBAAgB,CAAC,CAAC;IAC7D;AACR;AACA;AACA;AACA;AACA;IACQ,IAAIL,6BAA6B,KAAK,IAAI,IACtCA,6BAA6B,CAACM,IAAI,KAAK,oBAAoB,IAC3DJ,aAAa,CAACK,UAAU,CAAC,CAAC,CAACC,IAAI,CAACC,cAAc,KAAKC,SAAS,EAAE;MAC9D,OAAOb,+BAA+B,CAACK,aAAa,EAAEC,OAAO,CAAC;IAClE;IACAV,4BAA4B,CAACW,oBAAoB,EAAED,OAAO,CAAC;IAC3D,MAAMQ,KAAK,GAAGR,OAAO,CAACQ,KAAK,KAAK,IAAI,IAAIR,OAAO,CAACQ,KAAK,YAAYC,YAAY,GAAGT,OAAO,CAACQ,KAAK,GAAG,IAAIC,YAAY,CAACT,OAAO,CAACQ,KAAK,CAAC;IAC/H;IACA,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;MACpC,MAAMjB,uBAAuB,CAAC,CAAC;IACnC;IACA;IACAJ,2BAA2B,CAACY,oBAAoB,EAAE;MAAEO;IAAM,CAAC,EAAE,OAAO,CAAC;IACrEnB,2BAA2B,CAACY,oBAAoB,EAAED,OAAO,EAAE,YAAY,CAAC;IACxE,IAAIW,qCAAqC,GAAG,IAAI;IAChD,IAAIC,WAAW,GAAG,KAAK;IACvBd,kBAAkB,CAACG,oBAAoB,EAAE,OAAO,EAAGY,GAAG,IAAK,MAAMA,GAAG,CAACC,IAAI,CAACb,oBAAoB,CAAC,EAAGc,GAAG,IAAMC,KAAK,IAAK;MACjHD,GAAG,CAACD,IAAI,CAACb,oBAAoB,EAAEe,KAAK,CAAC;MACrC,IAAIJ,WAAW,EAAE;QACb,IAAIjB,SAAS,CAACqB,KAAK,CAAC,IAAIL,qCAAqC,KAAK,IAAI,EAAE;UACpEA,qCAAqC,GAAGnB,0CAA0C,CAACO,aAAa,EAAEE,oBAAoB,CAAC;QAC3H,CAAC,MACI,IAAI,CAACN,SAAS,CAACqB,KAAK,CAAC,IAAIL,qCAAqC,KAAK,IAAI,EAAE;UAC1EA,qCAAqC,CAAC,CAAC;UACvCA,qCAAqC,GAAG,IAAI;QAChD;MACJ;MACA,OAAOK,KAAK;IAChB,CAAC,CAAC;IACF,MAAMC,aAAa,GAAGA,CAAA,KAAM;MACxBL,WAAW,GAAG,IAAI;MAClB,IAAIjB,SAAS,CAACM,oBAAoB,CAACO,KAAK,CAAC,EAAE;QACvCG,qCAAqC,GAAGnB,0CAA0C,CAACO,aAAa,EAAEE,oBAAoB,CAAC;MAC3H;IACJ,CAAC;IACD,MAAMiB,gBAAgB,GAAGA,CAAA,KAAM;MAC3BN,WAAW,GAAG,KAAK;MACnB,IAAID,qCAAqC,KAAK,IAAI,EAAE;QAChDA,qCAAqC,CAAC,CAAC;QACvCA,qCAAqC,GAAG,IAAI;MAChD;IACJ,CAAC;IACD,OAAOf,kBAAkB,CAACK,oBAAoB,EAAEgB,aAAa,EAAEC,gBAAgB,CAAC;EACpF,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}