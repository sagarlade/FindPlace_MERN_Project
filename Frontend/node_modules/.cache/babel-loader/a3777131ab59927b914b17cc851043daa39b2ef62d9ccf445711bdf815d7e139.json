{"ast":null,"code":"import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({\n    ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach(({\n        name\n      }, index) => {\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[j];\n        }\n      }\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        colno: error.colno,\n        filename: error.filename,\n        lineno: error.lineno,\n        message: error.message\n      }));\n      break;\n    }\n  }\n  return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n      const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);\n      // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: outputChannelCount[i]\n          }));\n        }\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n          // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels,\n            // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n        return outputGainNode;\n      }\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam,\n          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm));\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam,\n          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm));\n        }\n      }\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n      return nativeAudioWorkletNode;\n    };\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n        return createAudioNode(proxy, nativeOfflineAudioContext);\n      }\n    };\n  };\n};","map":{"version":3,"names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","colno","filename","lineno","message","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","isArray","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","Promise","all","values","audioParam","constantSourceNode","offset","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","loop","loopEnd","loopStart","playbackRate","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js"],"sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                colno: error.colno,\n                filename: error.filename,\n                lineno: error.lineno,\n                message: error.message\n            }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-worklet-node-renderer-factory.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}