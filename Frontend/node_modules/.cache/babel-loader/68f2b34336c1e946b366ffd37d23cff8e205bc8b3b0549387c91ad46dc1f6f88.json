{"ast":null,"code":"export const createNativeMediaRecorderFactory = (createInvalidModificationError, createNotSupportedError) => {\n  return (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n    const bufferedBlobs = [];\n    const dataAvailableListeners = new WeakMap();\n    const errorListeners = new WeakMap();\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n    const stopListeners = new WeakMap();\n    let isActive = true;\n    nativeMediaRecorder.addEventListener = (addEventListener => {\n      return (type, listener, options) => {\n        let patchedEventListener = listener;\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = event => {\n              setTimeout(() => {\n                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                  bufferedBlobs.push(event.data);\n                } else {\n                  if (bufferedBlobs.length > 0) {\n                    const blob = event.data;\n                    Object.defineProperty(event, 'data', {\n                      value: new Blob([...bufferedBlobs, blob], {\n                        type: blob.type\n                      })\n                    });\n                    bufferedBlobs.length = 0;\n                  }\n                  listener.call(nativeMediaRecorder, event);\n                }\n              });\n            };\n            dataAvailableListeners.set(listener, patchedEventListener);\n          } else if (type === 'error') {\n            // Bug #12 & #13: Firefox fires a regular event with an error property.\n            patchedEventListener = event => {\n              // Bug #3 & #4: Chrome throws an error event without any error.\n              if (event.error === undefined) {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError()\n                }));\n                // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n              } else if (event.error.name === 'UnknownError') {\n                const message = event.error.message;\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError(message)\n                }));\n              } else if (event instanceof ErrorEvent) {\n                listener.call(nativeMediaRecorder, event);\n              } else {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: event.error\n                }));\n              }\n            };\n            errorListeners.set(listener, patchedEventListener);\n          } else if (type === 'stop') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = event => {\n              isActive = false;\n              setTimeout(() => listener.call(nativeMediaRecorder, event));\n            };\n            stopListeners.set(listener, patchedEventListener);\n          }\n        }\n        return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    })(nativeMediaRecorder.addEventListener);\n    nativeMediaRecorder.dispatchEvent = (dispatchEvent => {\n      // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n      return event => {\n        let wasActive;\n        setTimeout(() => {\n          wasActive = isActive;\n          isActive = false;\n        });\n        const returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n        setTimeout(() => isActive = wasActive);\n        return returnValue;\n      };\n    })(nativeMediaRecorder.dispatchEvent);\n    nativeMediaRecorder.removeEventListener = (removeEventListener => {\n      return (type, listener, options) => {\n        let patchedEventListener = listener;\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            const dataAvailableListener = dataAvailableListeners.get(listener);\n            if (dataAvailableListener !== undefined) {\n              patchedEventListener = dataAvailableListener;\n            }\n          } else if (type === 'error') {\n            const errorListener = errorListeners.get(listener);\n            if (errorListener !== undefined) {\n              patchedEventListener = errorListener;\n            }\n          } else if (type === 'stop') {\n            const stopListener = stopListeners.get(listener);\n            if (stopListener !== undefined) {\n              patchedEventListener = stopListener;\n            }\n          }\n        }\n        return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    })(nativeMediaRecorder.removeEventListener);\n    nativeMediaRecorder.start = (start => {\n      return timeslice => {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaRecorderOptions.mimeType !== undefined && mediaRecorderOptions.mimeType.startsWith('audio/') && stream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n        isActive = timeslice !== undefined;\n        return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n      };\n    })(nativeMediaRecorder.start);\n    return nativeMediaRecorder;\n  };\n};","map":{"version":3,"names":["createNativeMediaRecorderFactory","createInvalidModificationError","createNotSupportedError","nativeMediaRecorderConstructor","stream","mediaRecorderOptions","bufferedBlobs","dataAvailableListeners","WeakMap","errorListeners","nativeMediaRecorder","stopListeners","isActive","addEventListener","type","listener","options","patchedEventListener","event","setTimeout","state","push","data","length","blob","Object","defineProperty","value","Blob","call","set","error","undefined","ErrorEvent","name","message","dispatchEvent","wasActive","returnValue","removeEventListener","dataAvailableListener","get","errorListener","stopListener","start","timeslice","mimeType","startsWith","getVideoTracks"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/extendable-media-recorder/build/es2019/factories/native-media-recorder.js"],"sourcesContent":["export const createNativeMediaRecorderFactory = (createInvalidModificationError, createNotSupportedError) => {\n    return (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n        const bufferedBlobs = [];\n        const dataAvailableListeners = new WeakMap();\n        const errorListeners = new WeakMap();\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n        const stopListeners = new WeakMap();\n        let isActive = true;\n        nativeMediaRecorder.addEventListener = ((addEventListener) => {\n            return (type, listener, options) => {\n                let patchedEventListener = listener;\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event) => {\n                            setTimeout(() => {\n                                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                                    bufferedBlobs.push(event.data);\n                                }\n                                else {\n                                    if (bufferedBlobs.length > 0) {\n                                        const blob = event.data;\n                                        Object.defineProperty(event, 'data', {\n                                            value: new Blob([...bufferedBlobs, blob], { type: blob.type })\n                                        });\n                                        bufferedBlobs.length = 0;\n                                    }\n                                    listener.call(nativeMediaRecorder, event);\n                                }\n                            });\n                        };\n                        dataAvailableListeners.set(listener, patchedEventListener);\n                    }\n                    else if (type === 'error') {\n                        // Bug #12 & #13: Firefox fires a regular event with an error property.\n                        patchedEventListener = (event) => {\n                            // Bug #3 & #4: Chrome throws an error event without any error.\n                            if (event.error === undefined) {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: createInvalidModificationError() }));\n                                // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n                            }\n                            else if (event.error.name === 'UnknownError') {\n                                const message = event.error.message;\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: createInvalidModificationError(message) }));\n                            }\n                            else if (event instanceof ErrorEvent) {\n                                listener.call(nativeMediaRecorder, event);\n                            }\n                            else {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: event.error }));\n                            }\n                        };\n                        errorListeners.set(listener, patchedEventListener);\n                    }\n                    else if (type === 'stop') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event) => {\n                            isActive = false;\n                            setTimeout(() => listener.call(nativeMediaRecorder, event));\n                        };\n                        stopListeners.set(listener, patchedEventListener);\n                    }\n                }\n                return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.addEventListener);\n        nativeMediaRecorder.dispatchEvent = ((dispatchEvent) => {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            return (event) => {\n                let wasActive;\n                setTimeout(() => {\n                    wasActive = isActive;\n                    isActive = false;\n                });\n                const returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n                setTimeout(() => (isActive = wasActive));\n                return returnValue;\n            };\n        })(nativeMediaRecorder.dispatchEvent);\n        nativeMediaRecorder.removeEventListener = ((removeEventListener) => {\n            return (type, listener, options) => {\n                let patchedEventListener = listener;\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        const dataAvailableListener = dataAvailableListeners.get(listener);\n                        if (dataAvailableListener !== undefined) {\n                            patchedEventListener = dataAvailableListener;\n                        }\n                    }\n                    else if (type === 'error') {\n                        const errorListener = errorListeners.get(listener);\n                        if (errorListener !== undefined) {\n                            patchedEventListener = errorListener;\n                        }\n                    }\n                    else if (type === 'stop') {\n                        const stopListener = stopListeners.get(listener);\n                        if (stopListener !== undefined) {\n                            patchedEventListener = stopListener;\n                        }\n                    }\n                }\n                return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.removeEventListener);\n        nativeMediaRecorder.start = ((start) => {\n            return (timeslice) => {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaRecorderOptions.mimeType !== undefined &&\n                    mediaRecorderOptions.mimeType.startsWith('audio/') &&\n                    stream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n                isActive = timeslice !== undefined;\n                return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n            };\n        })(nativeMediaRecorder.start);\n        return nativeMediaRecorder;\n    };\n};\n//# sourceMappingURL=native-media-recorder.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}