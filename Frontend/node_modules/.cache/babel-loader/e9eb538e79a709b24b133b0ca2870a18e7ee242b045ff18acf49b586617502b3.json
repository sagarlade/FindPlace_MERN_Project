{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, ConstantSourceNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n  const {\n    encoderId,\n    port\n  } = await instantiate(mimeType, audioContext.sampleRate);\n  if (AudioWorkletNode === undefined) {\n    throw new Error(ERROR_MESSAGE);\n  }\n  const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, {\n    buffer: audioBuffer\n  });\n  const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, {\n    mediaStream\n  });\n  const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, {\n    channelCount\n  });\n  return {\n    audioBufferSourceNode,\n    encoderId,\n    mediaStreamAudioSourceNode,\n    port,\n    recorderAudioWorkletNode\n  };\n};\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n  return (eventTarget, mediaStream, mimeType) => {\n    var _a;\n    const sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n    const audioContext = new MinimalAudioContext({\n      latencyHint: 'playback',\n      sampleRate\n    });\n    const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n    const audioBuffer = new AudioBuffer({\n      length,\n      sampleRate: audioContext.sampleRate\n    });\n    const bufferedArrayBuffers = [];\n    const promisedAudioWorkletModule = addRecorderAudioWorkletModule(url => {\n      if (addAudioWorkletModule === undefined) {\n        throw new Error(ERROR_MESSAGE);\n      }\n      return addAudioWorkletModule(audioContext, url);\n    });\n    let abortRecording = null;\n    let intervalId = null;\n    let promisedAudioNodesAndEncoderId = null;\n    let promisedPartialRecording = null;\n    let isAudioContextRunning = true;\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n      if (promisedAudioNodesAndEncoderId === null) {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n    const resume = () => {\n      isAudioContextRunning = true;\n      return audioContext.resume();\n    };\n    const stop = () => {\n      if (promisedAudioNodesAndEncoderId === null) {\n        return;\n      }\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener('addtrack', abortRecording);\n        mediaStream.removeEventListener('removetrack', abortRecording);\n      }\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n      promisedAudioNodesAndEncoderId.then(async ({\n        constantSourceNode,\n        encoderId,\n        mediaStreamAudioSourceNode,\n        recorderAudioWorkletNode\n      }) => {\n        if (promisedPartialRecording !== null) {\n          promisedPartialRecording.catch(() => {\n            /* @todo Only catch the errors caused by a duplicate call to encode. */\n          });\n          promisedPartialRecording = null;\n        }\n        await recorderAudioWorkletNode.stop();\n        mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n        constantSourceNode.stop();\n        const arrayBuffers = await encode(encoderId, null);\n        if (promisedAudioNodesAndEncoderId === null) {\n          await suspend();\n        }\n        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n        bufferedArrayBuffers.length = 0;\n        eventTarget.dispatchEvent(new Event('stop'));\n      });\n      promisedAudioNodesAndEncoderId = null;\n    };\n    const suspend = () => {\n      isAudioContextRunning = false;\n      return audioContext.suspend();\n    };\n    suspend();\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n      get state() {\n        return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n      },\n      pause() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n        if (isAudioContextRunning) {\n          suspend();\n          eventTarget.dispatchEvent(new Event('pause'));\n        }\n      },\n      resume() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n        if (!isAudioContextRunning) {\n          resume();\n          eventTarget.dispatchEvent(new Event('resume'));\n        }\n      },\n      start(timeslice) {\n        var _a;\n        if (promisedAudioNodesAndEncoderId !== null) {\n          throw createInvalidStateError();\n        }\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n        eventTarget.dispatchEvent(new Event('start'));\n        const audioTracks = mediaStream.getAudioTracks();\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n        promisedAudioNodesAndEncoderId = Promise.all([resume(), promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))]).then(async ([, {\n          audioBufferSourceNode,\n          encoderId,\n          mediaStreamAudioSourceNode,\n          port,\n          recorderAudioWorkletNode\n        }]) => {\n          mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n          await new Promise(resolve => {\n            audioBufferSourceNode.onended = resolve;\n            audioBufferSourceNode.connect(recorderAudioWorkletNode);\n            audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n          });\n          audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n          // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n          const constantSourceNode = new ConstantSourceNode(audioContext, {\n            offset: 0\n          });\n          constantSourceNode.onended = () => constantSourceNode.disconnect();\n          constantSourceNode.connect(audioContext.destination);\n          constantSourceNode.start();\n          await recorderAudioWorkletNode.record(port);\n          if (timeslice !== undefined) {\n            promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n          }\n          return {\n            constantSourceNode,\n            encoderId,\n            mediaStreamAudioSourceNode,\n            recorderAudioWorkletNode\n          };\n        });\n        const tracks = mediaStream.getTracks();\n        abortRecording = () => {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        };\n        mediaStream.addEventListener('addtrack', abortRecording);\n        mediaStream.addEventListener('removetrack', abortRecording);\n        intervalId = setInterval(() => {\n          const currentTracks = mediaStream.getTracks();\n          if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1000);\n      },\n      stop\n    };\n  };\n};","map":{"version":3,"names":["encode","instantiate","addRecorderAudioWorkletModule","createRecorderAudioWorkletNode","AudioBuffer","AudioBufferSourceNode","AudioWorkletNode","ConstantSourceNode","MediaStreamAudioSourceNode","MinimalAudioContext","addAudioWorkletModule","ERROR_MESSAGE","createPromisedAudioNodesEncoderIdAndPort","audioBuffer","audioContext","channelCount","mediaStream","mimeType","encoderId","port","sampleRate","undefined","Error","audioBufferSourceNode","buffer","mediaStreamAudioSourceNode","recorderAudioWorkletNode","createWebAudioMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createInvalidStateError","createNotSupportedError","eventTarget","_a","getAudioTracks","getSettings","latencyHint","length","Math","max","ceil","baseLatency","bufferedArrayBuffers","promisedAudioWorkletModule","url","abortRecording","intervalId","promisedAudioNodesAndEncoderId","promisedPartialRecording","isAudioContextRunning","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","timeslice","push","resume","stop","removeEventListener","clearTimeout","then","constantSourceNode","catch","disconnect","suspend","Event","state","pause","start","getVideoTracks","audioTracks","Promise","all","connect","resolve","onended","currentTime","offset","destination","record","tracks","getTracks","ErrorEvent","error","addEventListener","setInterval","currentTracks","some","track","index"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/extendable-media-recorder/build/es2019/factories/web-audio-media-recorder.js"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, ConstantSourceNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        var _a;\n        const sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n            return addAudioWorkletModule(audioContext, url);\n        });\n        let abortRecording = null;\n        let intervalId = null;\n        let promisedAudioNodesAndEncoderId = null;\n        let promisedPartialRecording = null;\n        let isAudioContextRunning = true;\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n        const requestNextPartialRecording = async (encoderId, timeslice) => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            }\n            else {\n                dispatchDataAvailableEvent(arrayBuffers);\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n        const resume = () => {\n            isAudioContextRunning = true;\n            return audioContext.resume();\n        };\n        const stop = () => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n            promisedAudioNodesAndEncoderId.then(async ({ constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(() => {\n                        /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                }\n                await recorderAudioWorkletNode.stop();\n                mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                constantSourceNode.stop();\n                const arrayBuffers = await encode(encoderId, null);\n                if (promisedAudioNodesAndEncoderId === null) {\n                    await suspend();\n                }\n                dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                bufferedArrayBuffers.length = 0;\n                eventTarget.dispatchEvent(new Event('stop'));\n            });\n            promisedAudioNodesAndEncoderId = null;\n        };\n        const suspend = () => {\n            isAudioContextRunning = false;\n            return audioContext.suspend();\n        };\n        suspend();\n        return {\n            get mimeType() {\n                return mimeType;\n            },\n            get state() {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n            pause() {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n            resume() {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n            start(timeslice) {\n                var _a;\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n                eventTarget.dispatchEvent(new Event('start'));\n                const audioTracks = mediaStream.getAudioTracks();\n                // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                const channelCount = audioTracks.length === 0\n                    ? 2\n                    : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n                    // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n                    const constantSourceNode = new ConstantSourceNode(audioContext, { offset: 0 });\n                    constantSourceNode.onended = () => constantSourceNode.disconnect();\n                    constantSourceNode.connect(audioContext.destination);\n                    constantSourceNode.start();\n                    await recorderAudioWorkletNode.record(port);\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n                    return { constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n                const tracks = mediaStream.getTracks();\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n                    if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n            stop\n        };\n    };\n};\n//# sourceMappingURL=web-audio-media-recorder.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}