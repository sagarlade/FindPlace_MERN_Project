{"ast":null,"code":"import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n  return (nativeContext, options) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n    // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n    }\n    // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n    }\n    // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n    if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n    }\n    // Bug #44: Safari does not throw a RangeError yet.\n    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n    }\n    // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n    }\n    // Bug #44: Only Firefox does not throw a RangeError yet.\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n    }\n    // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n    addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n    return nativeAudioBufferSourceNode;\n  };\n};","map":{"version":3,"names":["assignNativeAudioNodeAudioParamValue","assignNativeAudioNodeOption","assignNativeAudioNodeOptions","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","createNativeAudioBufferSourceNodeFactory","addSilentConnection","cacheTestResult","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","nativeContext","options","nativeAudioBufferSourceNode","createBufferSource"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js"],"sourcesContent":["import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=native-audio-buffer-source-node-factory.js.map"],"mappings":"AAAA,SAASA,oCAAoC,QAAQ,uDAAuD;AAC5G,SAASC,2BAA2B,QAAQ,4CAA4C;AACxF,SAASC,4BAA4B,QAAQ,6CAA6C;AAC1F,SAASC,oDAAoD,QAAQ,yEAAyE;AAC9I,SAASC,yDAAyD,QAAQ,8EAA8E;AACxJ,SAASC,wDAAwD,QAAQ,6EAA6E;AACtJ,OAAO,MAAMC,wCAAwC,GAAGA,CAACC,mBAAmB,EAAEC,eAAe,EAAEC,2DAA2D,EAAEC,yDAAyD,EAAEC,yDAAyD,EAAEC,gEAAgE,EAAEC,6DAA6D,EAAEC,+DAA+D,EAAEC,mDAAmD,EAAEC,kDAAkD,EAAEC,sDAAsD,KAAK;EACpnB,OAAO,CAACC,aAAa,EAAEC,OAAO,KAAK;IAC/B,MAAMC,2BAA2B,GAAGF,aAAa,CAACG,kBAAkB,CAAC,CAAC;IACtEnB,4BAA4B,CAACkB,2BAA2B,EAAED,OAAO,CAAC;IAClEnB,oCAAoC,CAACoB,2BAA2B,EAAED,OAAO,EAAE,cAAc,CAAC;IAC1FlB,2BAA2B,CAACmB,2BAA2B,EAAED,OAAO,EAAE,QAAQ,CAAC;IAC3E;IACAlB,2BAA2B,CAACmB,2BAA2B,EAAED,OAAO,EAAE,MAAM,CAAC;IACzElB,2BAA2B,CAACmB,2BAA2B,EAAED,OAAO,EAAE,SAAS,CAAC;IAC5ElB,2BAA2B,CAACmB,2BAA2B,EAAED,OAAO,EAAE,WAAW,CAAC;IAC9E;IACA,IAAI,CAACX,eAAe,CAACC,2DAA2D,EAAE,MAAMA,2DAA2D,CAACS,aAAa,CAAC,CAAC,EAAE;MACjKf,oDAAoD,CAACiB,2BAA2B,CAAC;IACrF;IACA;IACA,IAAI,CAACZ,eAAe,CAACE,yDAAyD,EAAE,MAAMA,yDAAyD,CAACQ,aAAa,CAAC,CAAC,EAAE;MAC7JH,mDAAmD,CAACK,2BAA2B,CAAC;IACpF;IACA;IACA,IAAI,CAACZ,eAAe,CAACG,yDAAyD,EAAE,MAAMA,yDAAyD,CAACO,aAAa,CAAC,CAAC,EAAE;MAC7JF,kDAAkD,CAACI,2BAA2B,EAAEF,aAAa,CAAC;IAClG;IACA;IACA,IAAI,CAACV,eAAe,CAACI,gEAAgE,EAAE,MAAMA,gEAAgE,CAACM,aAAa,CAAC,CAAC,EAAE;MAC3Kd,yDAAyD,CAACgB,2BAA2B,CAAC;IAC1F;IACA;IACA,IAAI,CAACZ,eAAe,CAACK,6DAA6D,EAAE,MAAMA,6DAA6D,CAACK,aAAa,CAAC,CAAC,EAAE;MACrKD,sDAAsD,CAACG,2BAA2B,EAAEF,aAAa,CAAC;IACtG;IACA;IACA,IAAI,CAACV,eAAe,CAACM,+DAA+D,EAAE,MAAMA,+DAA+D,CAACI,aAAa,CAAC,CAAC,EAAE;MACzKb,wDAAwD,CAACe,2BAA2B,CAAC;IACzF;IACA;IACAb,mBAAmB,CAACW,aAAa,EAAEE,2BAA2B,CAAC;IAC/D,OAAOA,2BAA2B;EACtC,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}