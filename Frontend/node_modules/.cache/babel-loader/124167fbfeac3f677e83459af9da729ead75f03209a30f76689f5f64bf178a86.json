{"ast":null,"code":"export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n  return audioBuffer => {\n    audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const destinationLength = destination.length;\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n        destination[i] = channelData[i + bufferOffset];\n      }\n    };\n    audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const sourceLength = source.length;\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n        channelData[i + bufferOffset] = source[i];\n      }\n    };\n  };\n};","map":{"version":3,"names":["createWrapAudioBufferCopyChannelMethods","convertNumberToUnsignedLong","createIndexSizeError","audioBuffer","copyFromChannel","destination","channelNumberAsNumber","bufferOffsetAsNumber","bufferOffset","channelNumber","numberOfChannels","audioBufferLength","length","channelData","getChannelData","destinationLength","i","copyToChannel","source","sourceLength"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js"],"sourcesContent":["export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods.js.map"],"mappings":"AAAA,OAAO,MAAMA,uCAAuC,GAAGA,CAACC,2BAA2B,EAAEC,oBAAoB,KAAK;EAC1G,OAAQC,WAAW,IAAK;IACpBA,WAAW,CAACC,eAAe,GAAG,CAACC,WAAW,EAAEC,qBAAqB,EAAEC,oBAAoB,GAAG,CAAC,KAAK;MAC5F,MAAMC,YAAY,GAAGP,2BAA2B,CAACM,oBAAoB,CAAC;MACtE,MAAME,aAAa,GAAGR,2BAA2B,CAACK,qBAAqB,CAAC;MACxE,IAAIG,aAAa,IAAIN,WAAW,CAACO,gBAAgB,EAAE;QAC/C,MAAMR,oBAAoB,CAAC,CAAC;MAChC;MACA,MAAMS,iBAAiB,GAAGR,WAAW,CAACS,MAAM;MAC5C,MAAMC,WAAW,GAAGV,WAAW,CAACW,cAAc,CAACL,aAAa,CAAC;MAC7D,MAAMM,iBAAiB,GAAGV,WAAW,CAACO,MAAM;MAC5C,KAAK,IAAII,CAAC,GAAGR,YAAY,GAAG,CAAC,GAAG,CAACA,YAAY,GAAG,CAAC,EAAEQ,CAAC,GAAGR,YAAY,GAAGG,iBAAiB,IAAIK,CAAC,GAAGD,iBAAiB,EAAEC,CAAC,IAAI,CAAC,EAAE;QACtHX,WAAW,CAACW,CAAC,CAAC,GAAGH,WAAW,CAACG,CAAC,GAAGR,YAAY,CAAC;MAClD;IACJ,CAAC;IACDL,WAAW,CAACc,aAAa,GAAG,CAACC,MAAM,EAAEZ,qBAAqB,EAAEC,oBAAoB,GAAG,CAAC,KAAK;MACrF,MAAMC,YAAY,GAAGP,2BAA2B,CAACM,oBAAoB,CAAC;MACtE,MAAME,aAAa,GAAGR,2BAA2B,CAACK,qBAAqB,CAAC;MACxE,IAAIG,aAAa,IAAIN,WAAW,CAACO,gBAAgB,EAAE;QAC/C,MAAMR,oBAAoB,CAAC,CAAC;MAChC;MACA,MAAMS,iBAAiB,GAAGR,WAAW,CAACS,MAAM;MAC5C,MAAMC,WAAW,GAAGV,WAAW,CAACW,cAAc,CAACL,aAAa,CAAC;MAC7D,MAAMU,YAAY,GAAGD,MAAM,CAACN,MAAM;MAClC,KAAK,IAAII,CAAC,GAAGR,YAAY,GAAG,CAAC,GAAG,CAACA,YAAY,GAAG,CAAC,EAAEQ,CAAC,GAAGR,YAAY,GAAGG,iBAAiB,IAAIK,CAAC,GAAGG,YAAY,EAAEH,CAAC,IAAI,CAAC,EAAE;QACjHH,WAAW,CAACG,CAAC,GAAGR,YAAY,CAAC,GAAGU,MAAM,CAACF,CAAC,CAAC;MAC7C;IACJ,CAAC;EACL,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}