{"ast":null,"code":"import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n  return (nativeContext, baseLatency, processorConstructor, options) => {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n    const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);\n    // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n    if (outputChannelCount.some(channelCount => channelCount < 1)) {\n      throw createNotSupportedError();\n    }\n    if (outputChannelCount.length !== options.numberOfOutputs) {\n      throw createIndexSizeError();\n    }\n    // Bug #61: This is not part of the standard but required for the faker to work.\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n    // Bug #61: This is not part of the standard but required for the faker to work.\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n    const messageChannel = new MessageChannel();\n    const gainNodes = [];\n    const inputChannelSplitterNodes = [];\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n    const constantSourceNodes = [];\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      for (const {\n        defaultValue,\n        maxValue,\n        minValue,\n        name\n      } of processorConstructor.parameterDescriptors) {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n        });\n        Object.defineProperties(constantSourceNode.offset, {\n          defaultValue: {\n            get: () => defaultValue === undefined ? 0 : defaultValue\n          },\n          maxValue: {\n            get: () => maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n          },\n          minValue: {\n            get: () => minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n          }\n        });\n        constantSourceNodes.push(constantSourceNode);\n      }\n    }\n    const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters,\n    // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    const outputChannelMergerNodes = [];\n    for (let i = 0; i < options.numberOfOutputs; i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: outputChannelCount[i]\n      }));\n    }\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes[i].connect(inputChannelSplitterNodes[i]);\n      for (let j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n      }\n    }\n    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(({\n      name\n    }, index) => {\n      const constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    let channelInterpretation = options.channelInterpretation;\n    let onprocessorerror = null;\n    // Bug #87: Expose at least one output to make this node connectable.\n    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    const nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n      get channelCount() {\n        return options.channelCount;\n      },\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n      set channelInterpretation(value) {\n        for (const gainNode of gainNodes) {\n          gainNode.channelInterpretation = value;\n        }\n        channelInterpretation = value;\n      },\n      get context() {\n        return scriptProcessorNode.context;\n      },\n      get inputs() {\n        return gainNodes;\n      },\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n        onprocessorerror = typeof value === 'function' ? value : null;\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n      get parameters() {\n        return parameterMap;\n      },\n      get port() {\n        return messageChannel.port2;\n      },\n      addEventListener(...args) {\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n    };\n    const patchedEventListeners = new Map();\n    messageChannel.port1.addEventListener = (addEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n          if (unpatchedEventListener !== null) {\n            const patchedEventListener = patchedEventListeners.get(args[1]);\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = event => {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n              };\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.addEventListener);\n    messageChannel.port1.removeEventListener = (removeEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const patchedEventListener = patchedEventListeners.get(args[1]);\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.removeEventListener);\n    let onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: () => onmessage,\n      set: value => {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n        onmessage = typeof value === 'function' ? value : null;\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    let audioWorkletProcessor = null;\n    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(dWrkltPrcssr => audioWorkletProcessor = dWrkltPrcssr);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, {\n      name\n    }) => ({\n      ...prmtrs,\n      [name]: new Float32Array(128)\n    }), {});\n    let isActive = true;\n    const disconnectOutputsGraph = () => {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n        const outputChannelMergerNode = outputChannelMergerNodes[i];\n        for (let j = 0; j < outputChannelCount[i]; j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n        }\n        outputChannelSplitterNodeOutput += outputChannelCount[i];\n      }\n    };\n    const activeInputIndexes = new Map();\n    // tslint:disable-next-line:deprecation\n    scriptProcessorNode.onaudioprocess = ({\n      inputBuffer,\n      outputBuffer\n    }) => {\n      if (audioWorkletProcessor !== null) {\n        const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n        for (let i = 0; i < bufferSize; i += 128) {\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[j], k, k, i);\n            }\n          }\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(({\n              name\n            }, index) => {\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n          }\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[j][k].byteLength === 0) {\n                outputs[j][k] = new Float32Array(128);\n              }\n            }\n          }\n          try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n              const activeInput = activeInputs[index];\n              if (activeInput.size > 0) {\n                activeInputIndexes.set(index, bufferSize / 128);\n                return input;\n              }\n              const count = activeInputIndexes.get(index);\n              if (count === undefined) {\n                return [];\n              }\n              if (input.every(channelData => channelData.every(sample => sample === 0))) {\n                if (count === 1) {\n                  activeInputIndexes.delete(index);\n                } else {\n                  activeInputIndexes.set(index, count - 1);\n                }\n              }\n              return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            isActive = activeSourceFlag;\n            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n              for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n              }\n              outputChannelSplitterNodeOutput += outputChannelCount[j];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              colno: error.colno,\n              filename: error.filename,\n              lineno: error.lineno,\n              message: error.message\n            }));\n          }\n          if (!isActive) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n              for (let k = 0; k < options.channelCount; k += 1) {\n                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n              }\n            }\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              const length = processorConstructor.parameterDescriptors.length;\n              for (let j = 0; j < length; j += 1) {\n                const constantSourceNode = constantSourceNodes[j];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                constantSourceNode.stop();\n              }\n            }\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n            if (isConnected) {\n              disconnectOutputsGraph();\n            } else {\n              disconnectFakeGraph();\n            }\n            break;\n          }\n        }\n      }\n    };\n    let isConnected = false;\n    // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    const nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n    const disconnectFakeGraph = () => {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n    const whenConnected = () => {\n      if (isActive) {\n        disconnectFakeGraph();\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n      }\n      isConnected = true;\n    };\n    const whenDisconnected = () => {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n      isConnected = false;\n    };\n    connectFakeGraph();\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"names":["MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","computeBufferSize","copyFromChannel","copyToChannel","createAudioWorkletProcessor","createNestedArrays","ReadOnlyMap","createNativeAudioWorkletNodeFakerFactory","connectMultipleOutputs","createIndexSizeError","createInvalidStateError","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","createNativeScriptProcessorNode","createNotSupportedError","disconnectMultipleOutputs","exposeCurrentFrameAndCurrentTime","getActiveAudioWorkletNodeInputs","monitorConnections","nativeContext","baseLatency","processorConstructor","options","numberOfInputs","numberOfOutputs","outputChannelCount","Array","isArray","from","some","channelCount","length","channelCountMode","numberOfInputChannels","numberOfOutputChannels","reduce","sum","value","numberOfParameters","parameterDescriptors","undefined","messageChannel","MessageChannel","gainNodes","inputChannelSplitterNodes","i","push","channelInterpretation","gain","constantSourceNodes","defaultValue","maxValue","minValue","name","constantSourceNode","offset","parameterData","Object","defineProperties","get","inputChannelMergerNode","Math","max","bufferSize","sampleRate","scriptProcessorNode","outputChannelSplitterNode","outputChannelMergerNodes","connect","j","parameterMap","map","index","start","onprocessorerror","outputAudioNodes","nativeAudioWorkletNodeFaker","_","gainNode","context","inputs","removeEventListener","addEventListener","parameters","port","port2","args","bind","disconnect","dispatchEvent","patchedEventListeners","Map","port1","unpatchedEventListener","handleEvent","patchedEventListener","event","currentTime","set","call","delete","onmessage","defineProperty","prototype","audioWorkletProcessor","audioWorkletProcessorPromise","then","dWrkltPrcssr","outputs","prmtrs","Float32Array","isActive","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","activeInputIndexes","onaudioprocess","inputBuffer","outputBuffer","activeInputs","k","forEach","byteLength","potentiallyEmptyInputs","input","activeInput","size","count","every","channelData","sample","activeSourceFlag","process","error","ErrorEvent","colno","filename","lineno","message","stop","isConnected","disconnectFakeGraph","nativeGainNode","connectFakeGraph","destination","whenConnected","whenDisconnected"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js"],"sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: options.parameterData[name] !== undefined\n                        ? options.parameterData[name]\n                        : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = typeof value === 'function' ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = typeof args[1] === 'function'\n                        ? args[1]\n                        : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = typeof value === 'function' ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters = processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n        const activeInputIndexes = new Map();\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n                                return input;\n                            }\n                            const count = activeInputIndexes.get(index);\n                            if (count === undefined) {\n                                return [];\n                            }\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                }\n                                else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                            colno: error.colno,\n                            filename: error.filename,\n                            lineno: error.lineno,\n                            message: error.message\n                        }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-faker-factory.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}