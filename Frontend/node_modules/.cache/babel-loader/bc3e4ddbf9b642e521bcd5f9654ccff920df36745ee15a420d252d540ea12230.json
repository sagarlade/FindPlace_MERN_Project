{"ast":null,"code":"import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = nativeAudioNode => {\n  const connections = new Map();\n  nativeAudioNode.connect = (connect => {\n    // tslint:disable-next-line:invalid-void no-inferrable-types\n    return (destination, output = 0, input = 0) => {\n      const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n      // Save the new connection only if the calls to connect above didn't throw an error.\n      const connectionsToDestination = connections.get(destination);\n      if (connectionsToDestination === undefined) {\n        connections.set(destination, [{\n          input,\n          output\n        }]);\n      } else {\n        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({\n            input,\n            output\n          });\n        }\n      }\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n  nativeAudioNode.disconnect = (disconnect => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n      if (destinationOrOutput === undefined) {\n        connections.clear();\n      } else if (typeof destinationOrOutput === 'number') {\n        for (const [destination, connectionsToDestination] of connections) {\n          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);\n          if (filteredConnections.length === 0) {\n            connections.delete(destination);\n          } else {\n            connections.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections.has(destinationOrOutput)) {\n        if (output === undefined) {\n          connections.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections.get(destinationOrOutput);\n          if (connectionsToDestination !== undefined) {\n            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));\n            if (filteredConnections.length === 0) {\n              connections.delete(destinationOrOutput);\n            } else {\n              connections.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n      for (const [destination, connectionsToDestination] of connections) {\n        connectionsToDestination.forEach(connection => {\n          if (isNativeAudioNode(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};","map":{"version":3,"names":["isNativeAudioNode","wrapAudioNodeDisconnectMethod","nativeAudioNode","connections","Map","connect","destination","output","input","returnValue","connectionsToDestination","get","undefined","set","every","connection","push","bind","disconnect","destinationOrOutput","apply","clear","filteredConnections","filter","length","delete","has","forEach"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js"],"sourcesContent":["import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination, output = 0, input = 0) => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === undefined));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=wrap-audio-node-disconnect-method.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}