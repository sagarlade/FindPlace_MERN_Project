{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) => {\n  return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n    const audioTracks = mediaStream.getAudioTracks();\n    const bufferedArrayBuffers = [];\n    // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n    const channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    let promisedPartialRecording = null;\n    let stopRecording = () => {}; // tslint:disable-line:no-empty\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n      if (nativeMediaRecorder.state === 'inactive') {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n    const stop = () => {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n      stopRecording();\n      stopRecording = () => {}; // tslint:disable-line:no-empty\n      nativeMediaRecorder.stop();\n    };\n    nativeMediaRecorder.addEventListener('error', () => {\n      stop();\n      // Bug #3 & #4: Chrome throws an error event without any error.\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n      pause() {\n        return nativeMediaRecorder.pause();\n      },\n      resume() {\n        return nativeMediaRecorder.resume();\n      },\n      start(timeslice) {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n        if (nativeMediaRecorder.state === 'inactive') {\n          if (sampleRate === undefined) {\n            throw new Error('The sampleRate is not defined.');\n          }\n          let isRecording = false;\n          let isStopped = false;\n          // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n          let pendingInvocations = 0;\n          let promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n          stopRecording = () => {\n            isStopped = true;\n          };\n          const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(({\n            data\n          }) => {\n            pendingInvocations += 1;\n            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async ({\n              dataView = null,\n              elementType = null,\n              encoderId,\n              port\n            }) => {\n              const arrayBuffer = await data.arrayBuffer();\n              pendingInvocations -= 1;\n              const currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n              if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n                if (lengthAndValue === null) {\n                  return {\n                    dataView: currentDataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n                const {\n                  value\n                } = lengthAndValue;\n                if (value !== 172351395) {\n                  return {\n                    dataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n                isRecording = true;\n              }\n              const {\n                currentElementType,\n                offset,\n                contents\n              } = decodeWebMChunk(currentDataView, elementType, channelCount);\n              const remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n              contents.forEach(content => port.postMessage(content, content.map(({\n                buffer\n              }) => buffer)));\n              if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                encode(encoderId, null).then(arrayBuffers => {\n                  dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                  bufferedArrayBuffers.length = 0;\n                  eventTarget.dispatchEvent(new Event('stop'));\n                });\n                port.postMessage([]);\n                port.close();\n                removeEventListener();\n              }\n              return {\n                dataView: remainingDataView,\n                elementType: currentElementType,\n                encoderId,\n                port\n              };\n            });\n          });\n          if (timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(({\n              encoderId\n            }) => promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice));\n          }\n        }\n        nativeMediaRecorder.start(100);\n      },\n      stop\n    };\n  };\n};","map":{"version":3,"names":["encode","instantiate","MultiBufferDataView","on","createWebmPcmMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createNotSupportedError","decodeWebMChunk","readVariableSizeInteger","eventTarget","nativeMediaRecorderConstructor","mediaStream","mimeType","audioTracks","getAudioTracks","bufferedArrayBuffers","channelCount","length","undefined","getSettings","nativeMediaRecorder","sampleRate","promisedPartialRecording","stopRecording","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","encoderId","timeslice","state","push","stop","catch","addEventListener","ErrorEvent","error","Event","pause","resume","start","getVideoTracks","Error","isRecording","isStopped","pendingInvocations","promisedDataViewElementTypeEncoderIdAndPort","removeEventListener","then","dataView","elementType","port","arrayBuffer","currentDataView","buffers","byteOffset","lengthAndValue","value","currentElementType","offset","contents","remainingDataView","byteLength","forEach","content","postMessage","map","buffer","close"],"sources":["C:/Users/Santosh Lade/Desktop/MERN App/client/node_modules/extendable-media-recorder/build/es2019/factories/webm-pcm-media-recorder.js"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const audioTracks = mediaStream.getAudioTracks();\n        const bufferedArrayBuffers = [];\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount = audioTracks.length === 0\n            ? undefined\n            : audioTracks[0].getSettings().channelCount;\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n        const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n        let promisedPartialRecording = null;\n        let stopRecording = () => { }; // tslint:disable-line:no-empty\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n        const requestNextPartialRecording = async (encoderId, timeslice) => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            }\n            else {\n                dispatchDataAvailableEvent(arrayBuffers);\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n        const stop = () => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n            stopRecording();\n            stopRecording = () => { }; // tslint:disable-line:no-empty\n            nativeMediaRecorder.stop();\n        };\n        nativeMediaRecorder.addEventListener('error', () => {\n            stop();\n            // Bug #3 & #4: Chrome throws an error event without any error.\n            eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n        });\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n        return {\n            get mimeType() {\n                return mimeType;\n            },\n            get state() {\n                return nativeMediaRecorder.state;\n            },\n            pause() {\n                return nativeMediaRecorder.pause();\n            },\n            resume() {\n                return nativeMediaRecorder.resume();\n            },\n            start(timeslice) {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n                if (nativeMediaRecorder.state === 'inactive') {\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n                    const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(({ data }) => {\n                        pendingInvocations += 1;\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async ({ dataView = null, elementType = null, encoderId, port }) => {\n                            const arrayBuffer = await data.arrayBuffer();\n                            pendingInvocations -= 1;\n                            const currentDataView = dataView === null\n                                ? new MultiBufferDataView([arrayBuffer])\n                                : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n                            if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n                                if (lengthAndValue === null) {\n                                    return { dataView: currentDataView, elementType, encoderId, port };\n                                }\n                                const { value } = lengthAndValue;\n                                if (value !== 172351395) {\n                                    return { dataView, elementType, encoderId, port };\n                                }\n                                isRecording = true;\n                            }\n                            const { currentElementType, offset, contents } = decodeWebMChunk(currentDataView, elementType, channelCount);\n                            const remainingDataView = offset < currentDataView.byteLength\n                                ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                : null;\n                            contents.forEach((content) => port.postMessage(content, content.map(({ buffer }) => buffer)));\n                            if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                encode(encoderId, null).then((arrayBuffers) => {\n                                    dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                                    bufferedArrayBuffers.length = 0;\n                                    eventTarget.dispatchEvent(new Event('stop'));\n                                });\n                                port.postMessage([]);\n                                port.close();\n                                removeEventListener();\n                            }\n                            return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                        });\n                    });\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice)));\n                    }\n                }\n                nativeMediaRecorder.start(100);\n            },\n            stop\n        };\n    };\n};\n//# sourceMappingURL=webm-pcm-media-recorder.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}